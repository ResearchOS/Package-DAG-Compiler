{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Package-DAG-Compiler","text":"<p>The Directional Acyclic Graph (DAG) is a data structure (a type of Graph) that at its most fundamental level consists of nodes and directed (Directional) edges, and does not contain any loops (Acyclic). Typically, nodes are objects, and directed edges are the directional relationships between them, such as <code>gas -&gt; car</code> indicating that the car depends on gas. It is the same in this package. Typically, edges are notated using some variant of <code>source -&gt; target</code> (equivalently, <code>(source, target)</code>), which can be read in one of two ways:</p> <ol> <li>The target depends on the source.</li> <li>The source feeds in to the target.</li> </ol> <p>The second, more source-centric interpretation guides the design philosophy of this package. In the context of a workflow orchestration tool, where data flows from a dataset to a final output, I think this makes more sense. In the DAG, nodes are Runnable functions and the edges are the Variables' data flowing between them, the edges look more like <code>Runnable -&gt; Variable</code> which can be read as \"data from this Runnable node flows into this output Variable\". Similarly, <code>Variable -&gt; Runnable</code> indicates that data flows from a Variable and is an input to a Runnable.</p> <p>In this package, edges carry no meaning or metadata, they simply define directional connectivity. All of the metadata is contained in the node properties.</p> <p>At a high level, there are two types of nodes: Runnables, and Variables. Runnables represent things that you run, generally a function that you can call or a script you can run. Categories of Runnables include Process, Stats, and Plot. More on those later. The other node type is Variables, which as you would expect help direct the flow of data. Runnable nodes can only directly connect to Variables, they cannot connect to each other directly. However, Variable nodes can connect to either a Runnable or another Variable. The edges between nodes, whether they be Runnable -&gt; Variable, Variable -&gt; Runnable, or Variable - Variable, represent the flow of data between steps in a data processing pipeline. There can only be one connection between an output variable node and an input variable node without triggering a split in the DAG. A split is exactly what it sounds like. An exact copy of the subgraph of nodes descended from the current  Runnable node is created, and attached to that same Runnable node.</p> <p>Further Reading: 1. Recommended package directory structure     - Can use a template to generate the TOML files and directory structure 3. How to use this package     - Example project     - Templates     - Documentation per function     - Output is NetworkX graph</p>"},{"location":"dag_structure/","title":"DAG Structure","text":"<p>Todo</p> <ol> <li>Understand the types of DAG's that this compiler may generate. At the moment, it only puts out furcated (split) graphs. </li> <li>What does a split represent, why do I want it, and how do I trigger it?</li> <li></li> <li> <p>How the DAG is structured</p> <ul> <li>Node naming conventions, and how it relates to TOML</li> <li>Node metadata. Which metadata changes the hash?  </li> </ul> </li> <li> <p>Polyfurcations. What are they, when do they occur, why are they good, and what are the implementation details?</p> </li> </ol>"},{"location":"package_design/","title":"Package Design","text":"<p>This is where I'll detail the high-level (and probably some lower level) implementation details. Before diving in, I want to cover some relevant terminology.</p>"},{"location":"package_design/#highest-level-summary","title":"Highest Level Summary","text":"<p>At the highest level, this package does the following:</p>"},{"location":"package_design/#1-reads-toml-files-for-a-given-project","title":"1. Reads TOML files for a given project.","text":"<p>Finds all listed dependencies recursively. Goes from pyproject.toml through index.toml, to each Runnable file listed in the index.toml, and finally to the bridges.toml</p>"},{"location":"package_design/#2-constructs-a-directional-acyclic-graph-dag-from-those-toml-files","title":"2. Constructs a Directional Acyclic Graph (DAG) from those TOML files","text":"<p>Using the data from the TOML files, a DAG is constructed that defines a data processing pipeline, where data flows from source to target nodes.</p>"},{"location":"publishing_packages/","title":"Publishing Packages","text":"<p>You've created a set of TOML files, you've compiled them to a DAG, maybe you've even bridged your package with others to create something even more powerful, and you're ready to share your package with the world. </p> <p>There are multiple ways to share your package with the world.</p>"},{"location":"publishing_packages/#1-pypi","title":"1. PyPI","text":"<p>The Python Packaging Authority maintains the Python Packaging Index (PyPI), which is where the majority of Python packages reside. Packages in PyPI can be easily installed using <code>pip install</code>.</p>"},{"location":"publishing_packages/#2-github-or-other-online-version-control","title":"2. GitHub (or Other Online Version Control)","text":"<p>If your package is publicly visible and hosted in an online version control platform such as GitHub or another service, you can simply leave it there! Others can pip install directly from your GitHub repository.</p> <p>Todo</p>"},{"location":"templates/","title":"Template Structure","text":"<p>Todo</p> <p>Templates for new projects can be created using <code>ros create $package_name</code>. This section defines the structure of the template. What is the directory structure, which files are included, what information needs to be entered in order to share the package? How to integrate with others' packages?</p>"},{"location":"terms/","title":"Dictionary","text":"<p>Throughout the dictionary and the docs, you'll see notation for file and folder paths that may include dollar signs <code>$</code>. Whatever comes after this symbol is intended to be a dynamic variable, e.g. <code>$project_folder</code> will be replaced with the actual folder path for your project.</p>"},{"location":"terms/#dag","title":"DAG","text":"<p>A Directional Acyclic Graph (DAG) consisting of nodes and edges. Nodes can be Runnables or Variables, and edges represent the connections between nodes.</p>"},{"location":"terms/#indextoml","title":"index.toml","text":"<p>Recommended to be located at <code>$project_folder/src/$project_name/index.toml</code>. This file contains all of the file paths to all of the files that comprise this package. For maximum flexibility, the only requirement as to the structure of this file is that it consist only of dictionaries with any degree of nesting, where each key is whatever string the user wants, and the values are either a subdictionary, or an absolute file path. No relative file paths or other strings, no numbers, or lists are allowed outside of dictionaries.</p>"},{"location":"terms/#pyprojecttoml","title":"pyproject.toml","text":"<p>Recommended to be located at the root of your project folder, <code>pyproject.toml</code> is a type of text file that is Python's default way of providing the metadata needed to share Python packages. This is the only Python-standard .toml file, the rest are defined by me for the purposes of compiling a DAG from a TOML-based modular package format.</p>"},{"location":"terms/#runnable","title":"Runnable","text":""},{"location":"terms/#variable","title":"Variable","text":""},{"location":"terms/#runnable-process","title":"Runnable: Process","text":""},{"location":"terms/#runnable-plot","title":"Runnable: Plot","text":""},{"location":"terms/#runnable-summary","title":"Runnable: Summary","text":""},{"location":"toml_files/","title":"TOML Configuration Files","text":"<p>TOML (Tom's Obvious Minimal Language) is a configuration file syntax that defines a format for human and machine-readable structured plain text. I like it a lot because it's just as full featured as JSON and YAML, has multiple ways to represent the same dictionaries, unlike JSON and YAML (which I find helpful), and due to negligible indentation, TOML is a very robust and easy to work with language. Its primary downside is that it has not been around for as long as YAML or JSON, and so not every language has an existing TOML parser, and not all TOML parsers are created equal (some may not handle the more advanced features in TOML like arrays of tables).</p>"},{"location":"toml_files/#pyprojecttoml","title":"pyproject.toml","text":"<p>Python relies on pyproject.toml files for publishing packages. The default file structure is: <pre><code>[build-system]\nrequires = ['hatchling']\nbuild-backend = 'hatchling.build'\n\n[project]\nname = \"package_name\"\nversion = '0.1.0'\ndescription = 'Package description'\nauthors = [{name = \"Author Name\", email =\"author@email.com\"}]\ndependencies = []\n\n[tool.hatch.build.targets.wheel]\npackages = [\"src/package_name\"]\n\n[tool.package-dag-compiler]\nindex = \"index.toml\" # Path to the package's index.toml file\n</code></pre></p>"},{"location":"toml_files/#indextoml","title":"index.toml","text":"<p>This file points to all of the other files in the package. It can be any format, but every value must be a file path. At its simplest, it could contain just one file path: <pre><code>package_file = \"path/to/package_file.toml\"\n</code></pre> In larger packages with more files, more organization becomes useful. For example, categorizing paths by type: <pre><code>processes = [\n    \"path/to/process1.toml\",\n    \"path/to/process2.toml\"\n]\nplots = [\n    \"path/to/plots1.toml\"\n]\n</code></pre></p>"},{"location":"toml_files/#special-keys","title":"Special keys","text":"<ul> <li>bridges: The files that help connect the current package to others. <pre><code>runnables = [\n    \"path/to/runnables1.toml\",\n    \"path/to/runnables2.toml\"\n]\nbridges = \"path/to/bridges.toml\"\n</code></pre></li> </ul>"},{"location":"toml_files/#runnablestoml","title":"runnables.toml","text":"<p>The main contents of a package reside in its 1+ runnables' .toml files, of which there are multiple types. Every type of runnable needs at minimum the following attributes: <code>type</code>, <code>exec</code>, and <code>inputs</code>.</p> <p>Example runnable format: <pre><code>[runnable_name]\ntype = \"runnable_type\"\nexec = \"path/to/file.ext:func_name\"\ninputs.input1 = \"runnable1.variable1\"\n</code></pre></p>"},{"location":"toml_files/#process","title":"Process","text":"<p>Process type runnables are the most frequent runnable type. They process and transform data, and are the only type that has output variables. Inputs are identified by name, similar to keyword arguments available in most languages. As there are no named outputs, output variables are specified in a list in the same order that they are output.</p> <pre><code>[runnable_name]\ntype = \"process\"\nexec = \"path/to/file.ext:func_name\"\ninputs.input1 = \"runnable1.variable1\"\noutputs = [\n    \"output1\",\n    \"output2\"\n]\n</code></pre>"},{"location":"toml_files/#plot","title":"Plot","text":"<p>Plot type runnables are exactly what they sound like - they plot and visualize data.</p> <pre><code>[runnable_name]\ntype = \"plot\"\nexec = \"path/to/file.ext:func_name\"\ninputs.input1 = \"runnable1.variable1\"\n</code></pre>"},{"location":"toml_files/#summary","title":"Summary","text":"<p>Summary type runnables summarize the data.</p> <pre><code>[runnable_name]\ntype = \"summary\"\nexec = \"path/to/file.ext:func_name\"\ninputs.input1 = \"runnable1.variable1\"\n</code></pre>"},{"location":"toml_files/#bridgestoml","title":"bridges.toml","text":"<p>Bridges are the mechanism by which independently developed packages are connected together. The bridge name is just an identifier (unique within each package). Sources are the origin of the variable being bridged, and targets are where the variable is being directed to. Typically, there would either be just one source and multiple targets, or one target and multiple sources.</p> <p>Most projects just need one of these bridges files, althouh multiple bridges files are supported. If you find yourself with many bridges, consider splitting the package up into smaller packages.</p> <p>Here is a basic example bridges.toml file: <pre><code>[bridge_name]\nsources = [\n    \"package1.runnable1.output1\"\n]\ntargets = [\n    \"package2.runnable1.input1\"\n]\n</code></pre></p> <p>Note that each entry contains the package name, which is not included in the package's runnables.toml files because the referenced runnables are assumed to be located within the same package. When bridging, the package name must be specified explicitly to resolve potential naming conflicts between packages.</p>"},{"location":"toml_files/#one-source-multiple-targets","title":"One source, multiple targets","text":"<p>In this case, one output variable is being used as an input to multiple runnables. This is a common practice, as there are often computed variables that need to be used by multiple functions further along the pipeline.</p>"},{"location":"toml_files/#one-target-multiple-sources","title":"One target, multiple sources","text":"<p>In this case, one input variable is receiving data from multiple sources, triggering a polyfurcation of the DAG, with one branch per input variable. Most commonly this would happen with Plot and Summary runnables, to reuse the same runnable to plot or summarize multiple variables. </p> <p>In the below example, two variables are both being connected to the input variable for a Summary runnable. <pre><code>[summaries]\nsources = [\n    \"package1.runnable1.variable1\",\n    \"package1.runnable2.variable1\"\n]\ntargets = [\n    \"package2.summary1.data\"\n]\n</code></pre></p>"},{"location":"toml_files/#multiple-targets-multiple-sources","title":"Multiple targets, multiple sources","text":"<p>Todo</p> <p>Currently unsupported and will raise an error, though in the future I aim to support this. It will be treated as though it were a series of N bridges with one target and multiple sources, where N is the number of targets. Therefore, each source will be applied to each target</p>"}]}